<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Cardtable</title>
    <link rel="stylesheet" href="css/base.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0/react.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0/react-dom.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.15/browser.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="bower_components/classnames/index.js"></script>
    <script src="https://cdn.socket.io/socket.io-1.3.7.js"></script>
  </head>
  <body>
    <div id="content"></div>
    <script type="text/babel">

// Table - (this contains all table spaces)
var Table = React.createClass({
  getInitialState: function(){
    var socket = io.connect();
    socket.emit('initTable', this.props.id);
    return {
      id: this.props.id,
      socket: socket,
      // dimensions (TODO get from window)
      height: 1000,
      width: 1000,
      // will be filled in after render
      tablespaces: []
    };
  },
  updateTableState: function(data){
    var tablespacesWithData = data;
    // define dimensions
    // TODO noooott ssuuurrreee.......
    // this will eventually scale but we'll figure it out then, for now just defined statically here
    // size = element size + border
    var tablespaceDimensions = {x: 50, xBorder: 2, y: 70, yBorder: 2};

    // create a number of tablespaces based on dimensions of table
    // TODO account for border other than just +2
    var tablespacesX = Math.floor(this.state.width / (tablespaceDimensions.x + tablespaceDimensions.xBorder));
    var tablespacesY = Math.floor(this.state.height / (tablespaceDimensions.y + tablespaceDimensions.yBorder));
    var tablespaces = [];
    var x, y;
    for(y = 1; y <= tablespacesY; y++){
      for(x = 1; x <= tablespacesX; x++){
        var tablespaceId = y + ":" + x;
        var cards = (tablespacesWithData[tablespaceId])
          ? tablespacesWithData[tablespaceId]['cards'].map(function(card){
            return (
              <Card id={card.id} key={card.id} tablespaceId={tablespaceId} ordinal={card.ordinal} socket={this.state.socket} color={card.color} />
            )
          }.bind(this))
          : [];
        tablespaces.push(<Tablespace id={tablespaceId} key={tablespaceId} socket={this.state.socket} cards={cards} width={tablespaceDimensions.x} height={tablespaceDimensions.y} />);
      }
    }
    this.setState({tablespaces: []});
    this.setState({tablespaces: tablespaces});
  },
  componentDidMount: function(){
    // setup websocket listener for updates
    this.state.socket.on('updateTable', this.updateTableState);
  },
  dimensionsStyle: function(){
    return { width: this.state.width + 'px', height: this.state.height + 'px' };
  },
  render: function(){
    return (
      <div className="table" style={this.dimensionsStyle()} >
        {this.state.tablespaces}
      </div>
    );
  }
});

// TableSpace -  this is a space on a table where cards can be placed
var Tablespace = React.createClass({
  getInitialState: function(){
    return {
      id: this.props.id,
      height: this.props.height,
      width: this.props.width,
      cards: this.props.cards,
      tableSocket: this.props.socket
    };
  },
  dimensionsStyle: function(){
    return { minHeight: (this.state.height) + 'px', minWidth: this.state.width + 'px'};
  },
  sortedCards: function(){
    return this.state.cards.sort(function(a,b){
      if(a.props.ordinal > b.props.ordinal){
        return 1;
      }
      if(a.props.ordinal < b.props.ordinal){
        return -1;
      }
      return 0;
    });
  },
  dragOver: function(event){
    event.preventDefault();
  },
  drop: function(event){
    event.preventDefault();
    var cardId = event.dataTransfer.getData("cardId");
    var oldTablespaceId = event.dataTransfer.getData("oldTablespaceId");
    var oldOrdinal = parseInt(event.dataTransfer.getData("oldOrdinal"));
    // should only fire if this is an empty tablespace
    if(this.state.cards.length == 0){
      this.state.tableSocket.emit(
        'moveCardPosition',
        {cardId: cardId, oldTablespaceId: oldTablespaceId, newTablespaceId: this.state.id, oldOrdinal: oldOrdinal, newOrdinal: 0});
    }
  },
  render: function(){
    return (
      <div className="tablespace" style={this.dimensionsStyle()} onDragOver={this.dragOver} onDrop={this.drop}>
        {this.sortedCards()}
      </div>
    )
  }
});

// Card - this is a card
var Card = React.createClass({
  getInitialState: function(){
    return {
      id: this.props.id,
      tablespaceId: this.props.tablespaceId,
      color: this.props.color,
      tableSocket: this.props.socket,
      ordinal: this.props.ordinal,
      isDragHovered: false
    };
  },
  dragStart: function(event){
    this.setState({isDragging: true});
    event.dataTransfer.setData("cardId", this.state.id);
    event.dataTransfer.setData("oldTablespaceId", this.state.tablespaceId);
    event.dataTransfer.setData("oldOrdinal", this.state.ordinal);
  },
  dragEnd: function(event){
    this.setState({isDragging: false});
  },
  dragOver: function(event){
    if(!this.state.isDragging){
      var viewportOffset = event.currentTarget.getBoundingClientRect();
      if(event.clientY < (event.currentTarget.offsetHeight + viewportOffset.top) - (event.currentTarget.offsetHeight * .5)){
        this.setState({isDragHoveredAbove: true, isDragHovered: true});
      } else {
        this.setState({isDragHoveredAbove: false, isDragHovered: true});
      }
    }
  },
  dragLeave: function(event){
    this.setState({isDragHovered: false, isDragHoveredAbove: false});
  },
  mouseEnter: function(event){
    this.setState({isHovered: true})
  },
  mouseLeave: function(event){
    this.setState({isHovered: false})
  },
  drop: function(event){
    event.preventDefault();
    var cardId = event.dataTransfer.getData("cardId");
    var oldTablespaceId = event.dataTransfer.getData("oldTablespaceId");
    var oldOrdinal = parseInt(event.dataTransfer.getData("oldOrdinal"));
    var newOrdinal;
    if(this.state.isDragHovered){
      if(oldTablespaceId == this.state.tablespaceId){
        newOrdinal = (this.state.isDragHoveredAbove) ? ((this.state.ordinal-1 > 0) ? (this.state.ordinal-1) : 0) : (this.state.ordinal);
      } else {
        newOrdinal = (this.state.isDragHoveredAbove) ? this.state.ordinal : (this.state.ordinal+1);
      }
      this.state.tableSocket.emit(
        'moveCardPosition',
        {cardId: cardId, oldTablespaceId: oldTablespaceId, newTablespaceId: this.state.tablespaceId, oldOrdinal: oldOrdinal, newOrdinal: newOrdinal}
      );
    }
  },
  distanceFromTop: function(){
    return (this.state.ordinal * 10) + 'px';
  },
  cardStyle: function(){
    return { backgroundColor: this.state.color, top: this.distanceFromTop() }
  },
  render: function(){
    var classes = classNames({
      'card': true,
      'card-hovered': this.state.isHovered && !this.state.isDragHovered,
      'card-drag-hovered-above': this.state.isDragHovered && this.state.isDragHoveredAbove,
      'card-drag-hovered-below': this.state.isDragHovered && !this.state.isDragHoveredAbove
    });
    return (
      <div key={this.state.id} draggable="true" className={classes} style={this.cardStyle()} onDragOver={this.dragOver} onDragLeave={this.dragLeave} onDragStart={this.dragStart} onDrop={this.drop} onMouseEnter={this.mouseEnter} onMouseLeave={this.mouseLeave} />
    )
  }
});


ReactDOM.render(
 <Table id="1" />,
 document.getElementById('content')
);

    </script>
  </body>
</html>
