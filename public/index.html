<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Cardtable</title>
    <link rel="stylesheet" href="css/base.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0/react.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0/react-dom.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.15/browser.js"></script>
    <script src="bower_components/classnames/index.js"></script>
    <script src="https://cdn.socket.io/socket.io-1.3.7.js"></script>
  </head>
  <body>
    <div id="decks"></div>
    <div id="table"></div>
    <script type="text/babel">

// Table - (this contains all table spaces)
var Table = React.createClass({
  getInitialState: function(){
    var socket = io.connect();
    socket.emit('initTable', this.props.id);
    return {
      id: this.props.id,
      socket: socket,
      // dimensions (TODO get from window)
      height: 1000,
      width: 1000,
      // will be filled in after render
      tablespaces: []
    };
  },
  updateTableState: function(data){
    var tablespacesWithData = data;
    // define dimensions
    // TODO noooott ssuuurrreee.......
    // this will eventually scale but we'll figure it out then, for now just defined statically here
    // size = element size + border
    // xIncrease = css border+margin+padding (2+10+0)
    var tablespaceDimensions = {x: 70, xIncrease: 12, y: 90, yIncrease: 6};

    // create a number of tablespaces based on dimensions of table
    // TODO account for border other than just +2
    var tablespacesX = Math.floor(this.state.width / (tablespaceDimensions.x + tablespaceDimensions.xIncrease));
    var tablespacesY = Math.floor(this.state.height / (tablespaceDimensions.y + tablespaceDimensions.yIncrease));
    var tablespaces = [];
    var x, y;
    for(y = 1; y <= tablespacesY; y++){
      for(x = 1; x <= tablespacesX; x++){
        var tablespaceId = y + ":" + x;
        var cards = (tablespacesWithData[tablespaceId])
          ? tablespacesWithData[tablespaceId]['cards'].map(function(card){

            // inject card markup depending on whether it's faceup or down
            var markupComponent;
            if(card.face_up){
              markupComponent = <CardMarkup markup={card.front_markup} />;
            } else {
              markupComponent = <CardMarkup markup={card.back_markup} />;
            }

            return (
              <Card
                id={card.id}
                key={card.id}
                tablespaceId={tablespaceId}
                ordinal={card.ordinal}
                socket={this.state.socket}
                markupComponent={markupComponent}
                color={card.color}
                pile = {card.pile}
                cardsInPile = {card.cards_in_pile}
              />
            );
          }.bind(this))
          : [];
        tablespaces.push(<Tablespace id={tablespaceId} key={tablespaceId} socket={this.state.socket} cards={cards} width={tablespaceDimensions.x} height={tablespaceDimensions.y} />);
      }
    }
    this.setState({tablespaces: []});
    this.setState({tablespaces: tablespaces});
  },
  componentDidMount: function(){
    // setup websocket listener for updates
    this.state.socket.on('updateTable', this.updateTableState);
  },
  dimensionsStyle: function(){
    return { width: this.state.width + 'px', height: this.state.height + 'px' };
  },
  render: function(){
    return (
      <div className="table" style={this.dimensionsStyle()} >
        {this.state.tablespaces}
      </div>
    );
  }
});

// TableSpace -  this is a space on a table where cards can be placed
var Tablespace = React.createClass({
  getInitialState: function(){
    return {
      id: this.props.id,
      height: this.props.height,
      width: this.props.width,
      cards: this.props.cards,
      tableSocket: this.props.socket
    };
  },
  dimensionsStyle: function(){
    return { minHeight: (this.state.height) + 'px', minWidth: this.state.width + 'px' };
  },
  sortedCards: function(){
    return this.state.cards.sort(function(a,b){
      if(a.props.ordinal > b.props.ordinal){
        return 1;
      }
      if(a.props.ordinal < b.props.ordinal){
        return -1;
      }
      return 0;
    });
  },
  dragOver: function(event){
    event.preventDefault();
  },
  drop: function(event){
    event.preventDefault();
    var cardId = event.dataTransfer.getData("cardId");
    var deckName = event.dataTransfer.getData("deckName");

    // dragging a card onto this tablespace
    if(cardId){
      var cardPile = event.dataTransfer.getData("cardPile");
      var oldTablespaceId = event.dataTransfer.getData("oldTablespaceId");
      var oldOrdinal = parseInt(event.dataTransfer.getData("oldOrdinal"));
      // should only fire if this is an empty tablespace
      if(this.state.cards.length == 0){
        this.state.tableSocket.emit(
          'moveCardPosition',
          {
            cardId: cardId,
            oldTablespaceId: oldTablespaceId,
            newTablespaceId: this.state.id,
            oldOrdinal: oldOrdinal,
            newOrdinal: 0
          }
        );
      }
    }

    // dragging a deck onto this tablespace
    if(deckName){
      this.state.tableSocket.emit('loadDeck', {deckName: deckName, tablespaceId: this.state.id});
    }
  },
  render: function(){
    return (
      <div className="tablespace" style={this.dimensionsStyle()} onDragOver={this.dragOver} onDrop={this.drop}>
        {this.sortedCards()}
      </div>
    )
  }
});

// Card - this is a card
var Card = React.createClass({
  getInitialState: function(){
    return {
      id: this.props.id,
      tablespaceId: this.props.tablespaceId,
      markupComponent: this.props.markupComponent,
      color: this.props.color,
      ordinal: this.props.ordinal,
      isPile: (this.props.pile) ? true : false,
      pile: this.props.pile,
      cardsInPile: this.props.cardsInPile,

      // events
      tableSocket: this.props.socket,

      // UI
      isDragHovered: false,
      contextMenu: false
    };
  },
  dragStart: function(event){
    this.setState({isDragging: true});
    event.dataTransfer.setData("cardId", this.state.id);
    event.dataTransfer.setData("oldTablespaceId", this.state.tablespaceId);
    event.dataTransfer.setData("oldOrdinal", this.state.ordinal);
    event.dataTransfer.setData("cardPile", this.state.pile);
  },
  dragEnd: function(event){
    this.setState({isDragging: false});
  },
  dragOver: function(event){
    if(!this.state.isDragging){
      var viewportOffset = event.currentTarget.getBoundingClientRect();
      if(event.clientY < (event.currentTarget.offsetHeight + viewportOffset.top) - (event.currentTarget.offsetHeight * .5)){
        this.setState({isDragHoveredAbove: true, isDragHovered: true});
      } else {
        this.setState({isDragHoveredAbove: false, isDragHovered: true});
      }
    }
  },
  dragLeave: function(event){
    this.setState({isDragHovered: false, isDragHoveredAbove: false});
  },
  mouseEnter: function(event){
    this.setState({isHovered: true});
  },
  mouseLeave: function(event){
    this.setState({isHovered: false, contextMenu: false});
  },
  contextMenu: function(event){
    event.preventDefault();
    this.setState({contextMenu: true});
  },
  drop: function(event){
    event.preventDefault();
    var cardId = event.dataTransfer.getData("cardId");
    if(cardId){
      var cardPile = event.dataTransfer.getData("cardPile");
      var oldTablespaceId = event.dataTransfer.getData("oldTablespaceId");
      var oldOrdinal = parseInt(event.dataTransfer.getData("oldOrdinal"));
      var newOrdinal;
      if(this.state.isDragHovered){
        if(oldTablespaceId == this.state.tablespaceId){
          newOrdinal = (this.state.isDragHoveredAbove) ? ((this.state.ordinal-1 > 0) ? (this.state.ordinal-1) : 0) : (this.state.ordinal);
        } else {
          newOrdinal = (this.state.isDragHoveredAbove) ? this.state.ordinal : (this.state.ordinal+1);
        }
        this.state.tableSocket.emit(
          'moveCardPosition',
          {
            cardId: cardId,
            cardPile: cardPile,
            oldTablespaceId: oldTablespaceId,
            newTablespaceId: this.state.tablespaceId,
            oldOrdinal: oldOrdinal,
            newOrdinal: newOrdinal
          }
        );
      }
    }
  },
  distanceFromTop: function(){
    // if this is a pile we need to maneuver the ordinal so that it doesn't make gaps
    return ((this.state.ordinal * 10) - ((this.state.cardsInPile-1) * 10)) + 'px';
  },
  cardStyle: function(){
    return { backgroundColor: this.state.color, top: this.distanceFromTop() }
  },
  makePile: function(){
    this.state.tableSocket.emit('pileTablespace', {tablespaceId: this.state.tablespaceId});
  },
  contextMenuItems: function(){
    var contextMenuItems = [];
    if(this.state.isPile){
      contextMenuItems.push(<ContextMenuItem key="shufflePile" text="Shuffle Pile" onClickFunction={this.shufflePile} />);
      contextMenuItems.push(<ContextMenuItem key="turnOverCard" text="Turn Over Top Card" onClickFunction={this.turnOverCard} />);
      contextMenuItems.push(<ContextMenuItem key="turnOverPile" text="Turn Over All Cards" onClickFunction={this.turnOverPile} />);
    } else {
      contextMenuItems.push(<ContextMenuItem key="makePile" text="Pile Tablespace" onClickFunction={this.makePile} />);
      contextMenuItems.push(<ContextMenuItem key="turnOverCard" text="Turn Over" onClickFunction={this.turnOverCard} />);
    }
    return contextMenuItems;
  },
  render: function(){
    var classes = classNames({
      'card': true,
      'card-hovered': this.state.isHovered && !this.state.isDragHovered,
      'card-drag-hovered-above': this.state.isDragHovered && this.state.isDragHoveredAbove,
      'card-drag-hovered-below': this.state.isDragHovered && !this.state.isDragHoveredAbove
    });
    if(this.state.contextMenu){
      var contextMenu = <ContextMenu contextMenuItems={this.contextMenuItems()}/>;
    }
    return (
      <div
        key={this.state.id}
        draggable="true"
        className={classes}
        style={this.cardStyle()}
        onDragOver={this.dragOver}
        onDragLeave={this.dragLeave}
        onDragStart={this.dragStart}
        onDrop={this.drop}
        onMouseEnter={this.mouseEnter}
        onMouseLeave={this.mouseLeave}
        onContextMenu={this.contextMenu}
      >
      {this.state.markupComponent}
      {contextMenu}
      </div>
    );
  }
});

// CardMarkup
// this is a skeleton component for holding the raw html
// used for templating cards by users
// it's uh .. scary and awful.  but all in the name of ease for card game developers
var CardMarkup = React.createClass({
  getInitialState: function(){
    return {
      markup: this.props.markup
    };
  },
  // live dangerously
  markup: function(){
    return { __html: this.state.markup };
  },
  render: function(){
    return (
      <div dangerouslySetInnerHTML={this.markup()} />
    );
  }
});

// ContextMenu shows when you right click on a card (or maybe other things too?)
var ContextMenu = React.createClass({
  getInitialState: function(){
    return {
      contextMenuItems: this.props.contextMenuItems
    };
  },
  render: function(){
    return (
      <ul>
        {this.state.contextMenuItems}
      </ul>
    );
  }
});

var ContextMenuItem = React.createClass({
  getInitialState: function(){
    return {
      text: this.props.text,
      onClickFunction: this.props.onClickFunction
    };
  },
  render: function(){
    return (
      <li><a href="#" onClick={this.state.onClickFunction}>{this.state.text}</a></li>
    );
  }
});

var Decklist = React.createClass({
  getInitialState: function(){
    var socket = io.connect();
    socket.emit('initDecks');
    return {
      socket: socket,
      decks: []
    };
  },
  componentDidMount: function(){
    this.state.socket.on('updateDecks', this.updateDecks);
  },
  updateDecks: function(data){
    this.setState({decks: data.map(function(deck){ return <Deck key={deck} name={deck} /> } )});
  },
  render: function(){
    return (
      <div className="decklist">
        <ul>
          {this.state.decks}
        </ul>
      </div>
    );
  }
});

var Deck = React.createClass({
  getInitialState: function(){
    return {
      name: this.props.name,
      isDragging: false
    };
  },
  dragStart: function(event){
    this.setState({isDragging: true});
    event.dataTransfer.setData("deckName", this.state.name);
  },
  dragEnd: function(event){
    this.setState({isDragging: false});
  },
  render: function(){
    return (
      <li draggable="true" onDragStart={this.dragStart} className="deck">{this.state.name}</li>
    );
  }
});


ReactDOM.render(
  <Decklist />,
  document.getElementById('decks')
);

ReactDOM.render(
 <Table id="1" />,
 document.getElementById('table')
);

    </script>
  </body>
</html>
